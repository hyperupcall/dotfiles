# shellcheck shell=bash

util.req() {
	curl --proto '=https' --tlsv1.2 -sSLf "$@"
}

util.run() {
	core.print_info "Executing '$*'"
	if "$@"; then
		return $?
	else
		return $?
	fi
}

util.ensure() {
	if "$@"; then :; else
		core.print_die "'$*' failed (code $?)"
	fi
}

util.ensure_bin() {
	if ! command -v "$1" &>/dev/null; then
		core.print_die "Command '$1' does not exist"
	fi
}

util.is_cmd() {
	if command -v "$1" &>/dev/null; then
		return $?
	else
		return $?
	fi
}

util.clone() {
	local repo="$1"
	local dir="$2"

	if [ ! -d "$dir" ]; then
		core.print_info "Cloning '$repo' to $dir"
		git clone "$repo" "$dir"
	fi
}

util.clone_in_dots() {
	local repo="$1"
	util.clone "$repo" ~/.dots/.repos/"${repo##*/}"
}

util.find_mnt_usb() {
	local usb_partition_uuid="$1"

	local block_dev="/dev/disk/by-uuid/$usb_partition_uuid"
	if [ ! -e "$block_dev" ]; then
		core.print_die "USB Not plugged in"
	fi

	local block_dev_target=
	if ! block_dev_target=$(findmnt -no TARGET "$block_dev"); then
		# 'findmnt' exits failure if cannot find block device. We account
		# for that case with '[ -z "$block_dev_target" ]' below
		:
	fi

	# If the USB is not already mounted
	if [ -z "$block_dev_target" ]; then
		if mountpoint -q /mnt; then
			core.print_die "Directory '/mnt' must not already be a mountpoint"
		fi

		util.run sudo mount "$block_dev" /mnt

		if ! block_dev_target=$(findmnt -no TARGET "$block_dev"); then
			core.print_die "Automount failed"
		fi
	fi

	REPLY=$block_dev_target
}

helper.dotfox_deploy() {
	local dotfox=
	if util.is_cmd dotfox; then
		dotfox='dotfox'
	else
		core.print_warn "Using dotfox from ~/.bootstrap"
		dotfox="$HOME/.bootstrap/dotfox/dotfox"
	fi

	"$dotfox" --config-dir="$HOME/.dots/user/.config/dotfox" --deployment=all.sh deploy
}


helper.dotshellextract() {
	# Bash is the most featureful lowest common denominator in shells
	# on Unix machines. We extract bash intrinsics with the '# clone(...)'
	# annotations such that funtions, aliases, and readline declarations
	# can be shared more easily across *nix machines

	# ------------------- Utility Functions ------------------ #
	util_print_autogen_info() {
		cat <<-EOF
		# shellcheck shell=bash
		# Autogenerated using code from gh:hyperupcall/dotshellextract
		EOF
	}

	util_print_file() {
		echo "# Autogenerated from file. Do NOT edit!"
		echo "# --------------------------------------------------------------------------------"

		cat "$1"
	}

	# Ex.
	# alias l='ls -al' # clone(user, root)
	util_extract_alias() {
		sed -En "s/^(.*?) ?# ?clone ?(\(|.*?, )$1(\)|, ).*?$/# Autogenerated. Do NOT edit!\\n\1\\n/p"
	}

	# Ex.
	# set convert-meta off # clone(user, root)
	# util_extract_readline() {
	# 	sed -En "s/^(.*?) ?# ?clone ?(\(|.*?, )$1(\)|, ).*?$/# Autogenerated. Do NOT edit!\\n\1\\n/p"
	# }


	# ----------------------- Variables ---------------------- #
	generated_dir=${XDG_STATE_HOME:-$HOME/.local/state}/dotshellextract
	current_dir="$BASALT_PACKAGE_DIR/pkg/src/bin"
	profile_dir="$XDG_CONFIG_HOME/shell"

	mkdir -p "$generated_dir"

	# ------------------------- Main ------------------------- #
	# user Functions
	exec 6> "$generated_dir/.bashrc-user-functions.sh"
	util_print_autogen_info >&6
	find "$XDG_CONFIG_HOME/shell/modules/functions/" -ignore_readdir_race -type f -name "*.sh" \
			-exec sh -c "\"$DOTMGR_ROOT/share/extract_functions.pl\" 'user' < \"\$0\"" {} \; >&6
	util_print_file "$profile_dir/modules/util.sh" >&6
	exec 6<&-

	# user Aliases
	exec 6> "$generated_dir/.bashrc-user-aliases.sh"
	util_print_autogen_info >&6
	find "$XDG_CONFIG_HOME/shell/modules/aliases/" -ignore_readdir_race -type f -name "*.sh" \
			-exec sh -c 'cat < $0' {} \; \
		| util_extract_alias 'user' >&6
	util_print_file "$profile_dir/modules/aliases/aliases.sh" >&6
	exec 6<&-

	# user Readline
	exec 6> "$generated_dir/.bashrc-user-readline.sh"
	util_print_file "$XDG_CONFIG_HOME/bash/modules/readline.sh" >&6
	exec 6<&-



	# root Functions
	exec 6> "$generated_dir/.bashrc-root-functions.sh"
	util_print_autogen_info >&6
	find "$XDG_CONFIG_HOME/shell/modules/functions/" -ignore_readdir_race -type f -name "*.sh" \
			-exec sh -c "\"$DOTMGR_ROOT/share/extract_functions.pl\" 'root' < \"\$0\"" {} \; >&6
	util_print_file "$profile_dir/modules/util.sh" >&6
	exec 6<&-

	# root Aliases
	exec 6> "$generated_dir/.bashrc-root-aliases.sh"
	util_print_autogen_info >&6
	find "$XDG_CONFIG_HOME/shell/modules/aliases/" -ignore_readdir_race -type f -name "*.sh" \
			-exec sh -c 'cat < $0' {} \; \
		| util_extract_alias 'root' >&6
	util_print_file "$profile_dir/modules/aliases/aliases.sh" >&6
	exec 6<&-

	# root Readline
	exec 6> "$generated_dir/.bashrc-root-readline.sh"
	util_print_file "$XDG_CONFIG_HOME/bash/modules/readline.sh" >&6
	exec 6<&-
}

helper.dotshellgen() {
	# ------------------- Utility Functions ------------------ #
	is_in_array() {
		local array_name="$1"
		local value="$2"

		local -n array="$array_name"

		local item=
		for item in "${array[@]}"; do
			if [ "$item" = "$value" ]; then
				return 0
			fi
		done; unset -v item

		return 1
	}

	concat() {
		local file="$1"

		local file_name="${file##*/}"

		case "$file_name" in
		*.bash)
			local -n output_file='concatenated_bash_file'
			;;
		*.zsh)
			local -n output_file='concatenated_zsh_file'
			;;
		*.fish)
			local -n output_file='concatenated_fish_file'
			;;
		*.sh)
			local -n output_file='concatenated_sh_file'
			;;
		*)
			core.print_warn "Skipping '$file_name'"
			return
			;;
		esac

		{
			printf '# %s\n' "$file_name"
			cat "$file"
			printf '\n'
		} >> "$output_file"
	}

	local flag_clear='no'
	local arg=
	for arg; do case $arg in
		-h|--help) printf '%s\n' "Usage: [-h|--help] [--clear]"; return ;;
		--clear) flag_clear='yes'
	esac done


	local dotshellgen_config_dir="$XDG_CONFIG_HOME/dotshellgen"
	local dotshellgen_state_dir="$XDG_STATE_HOME/dotshellgen"
	mkdir -p "$dotshellgen_config_dir" "$dotshellgen_state_dir"

	local concatenated_bash_file="$dotshellgen_state_dir/concatenated.bash"
	local concatenated_zsh_file="$dotshellgen_state_dir/concatenated.zsh"
	local concatenated_fish_file="$dotshellgen_state_dir/concatenated.fish"
	local concatenated_sh_file="$dotshellgen_state_dir/concatenated.sh"

	if [ "$flag_clear" = 'yes' ]; then
		rm -f "$concatenated_bash_file" "$concatenated_zsh_file" "$concatenated_fish_file" "$concatenated_sh_file"
		core.print_warn 'Cleared all generated files'
		return
	fi

	# Nuke all concatenated files
	> "$concatenated_bash_file" :
	> "$concatenated_zsh_file" :
	> "$concatenated_fish_file" :
	> "$concatenated_sh_file" :

	declare -a pre=() post=() disabled=()
	source "$dotshellgen_config_dir/config.sh"

	local dirname=
	for dirname in "${pre[@]}"; do
		for file in "$dotshellgen_config_dir/$dirname"/*; do
			concat "$file"
		done; unset -v file
	done; unset -v dirname

	local dir=
	for dir in "$dotshellgen_config_dir"/*/; do
		local dirname="${dir%/}"; dirname=${dirname##*/}

		if is_in_array 'pre' "$dirname"; then
			continue
		fi
		if is_in_array 'post' "$dirname"; then
			continue
		fi

		if is_in_array 'disabled' "$dirname"; then
			continue
		fi

		local file=
		for file in "$dir"/*; do
			concat "$file"
		done; unset -v file
	done; unset -v dir

	local dirname=
	for dirname in "${post[@]}"; do
		for file in "$dotshellgen_config_dir/$dirname"/*; do
			concat "$file"
		done; unset -v file
	done; unset -v dirname

	printf '%s\n' 'Done.'
}
