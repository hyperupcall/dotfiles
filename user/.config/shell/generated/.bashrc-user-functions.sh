# shellcheck shell=bash
# Autogenerated from generate-remote-shellrcs.sh in https://github.com/eankeen/dots

# Autogenerated. Do NOT edit!
chr() {
	[ -z "$1" ] && { _shell_util_die "chr: No mountpoint specified"; return; }
	[ -d "$1" ] || { _shell_util_die "chr: Folder doesn't exist"; return; }

	command -v arch-chroot >/dev/null 2>&1 && {
		if [ "$TERM" = xterm-kitty ]; then
			TERM="xterm-256color" sudo arch-chroot "$@"
		else
			sudo arch-chroot "$@"
		fi
	}

	sudo mount -o bind -t proc /proc "$1/proc"
	sudo mount -o bind -t sysfs /sys "$1/sys"
	sudo mount -o bind -t tmpfs /run "$1/run"
	sudo mount -o bind -t devtmpfs /dev "$1/dev"

	if [ "$TERM" = xterm-kitty ]; then
			TERM="xterm-256color" 	sudo chroot "$@"
	else
			sudo chroot "$@"
	fi
}

# Autogenerated. Do NOT edit!
unchr() {
	[ -z "$1" ] && { _shell_util_die "unchr: No mountpoint specified"; return; }
	[ -d "$1" ] || { _shell_util_die "unchr: Folder doesn't exist"; return; }

	umount "$1/proc"
	umount "$1/sys"
	umount "$1/run"
	umount "$1/dev"
}

# Autogenerated. Do NOT edit!
a() {
    # TODO: BASH_ALIASES
	if alias "$1" >/dev/null 2>&1; then
		_a_aliasValue="$(alias "$1" | awk -v FS="'" '{ print $2 }')"

		# history -s "$_a_aliasValue"
		# history -s "$1"
		$_a_aliasValue
	else
		_shell_util_die "a: Alias '$1' not found"
		return
	fi
}

# Autogenerated. Do NOT edit!
r() {
	for file; do
		if [ -d "$file" ]; then
			command rmdir "$file"
		else
			command rm "$file"
		fi
	done
	unset -v file
}

# Autogenerated. Do NOT edit!
s() {
	BASH_ENV="/root/.bashrc" sudo -i --preserve-env=BASH_ENV "$@"
}

# Autogenerated. Do NOT edit!
t() {
	[ $# -eq 0 ] && {
		_shell_util_log_error 't: Missing file arguments'
		return
	}

	for arg; do
		case "$arg" in
		-a*|-c*|--no-create*|-d*|--date*|-f*|-h*|--no-dereference*|-m*|-r*|--reference*|-t*|--time*|--help*|--version*|--)
			_shell_util_log_die "t: Args detected. Please use 'touch'"
			return
			;;
		esac
	done
	unset -v arg

	for file; do
		mkdir -p "$(dirname "$file")"
		command touch "$file"
	done
	unset -v file
}

# Autogenerated. Do NOT edit!
v() {
	s=
	if [ -e "$1" ] && [ "$(stat -c "%G" "$1")" = "root" ]; then
		s="sudo"
	fi

	_v_editor="${EDITOR:-vi}"

	if [ $# -eq 0 ]; then
		"$_v_editor" .
	else
		[ $# -eq 1 ] && $s mkdir -p "$(dirname "$1")"
		$s "$_v_editor" "$@"
	fi

	unset -v _v_editor
}

# Autogenerated. Do NOT edit!
del() {
	if command -v trash-put >/dev/null 2>&1; then
		for f; do
			trash-put "$f" || {
				_shell_util_die "del: 'trash-put' failed"
				return
			}
		done
	elif command -v gio >/dev/null 2>&1; then
		for f; do
			gio trash "$f" || {
				_shell_util_die "del: 'gio trash' failed"
				return
			}
		done
	else
		_shell_util_log_error "del: Neither 'trash-cli' nor 'gio' installed. Falling back to 'rm'"
		rm -rf "$@"
	fi
}

# Autogenerated. Do NOT edit!
bash() {
	if { [ "$1" = --noprofile ] && [ "$2" = --norc ]; } \
		|| { [ "$1" = --norc ] && [ "$2" = --noprofile ]; }
	then
		_shell_util_log_info "Additionally resetting path to a sane default"
		PATH="/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin" command bash "$@"
	else
		command bash "$@"
	fi
}

# Autogenerated. Do NOT edit!
cls() {
	# assume hardware is not real (not 'reset')
	tput reset

	# this uses our 'stty' function
	stty sane
}

# Autogenerated. Do NOT edit!
cdp() {
	if [ -z "$_shell_cdp_dir" ]; then
		_shell_util_log_error "Variable '_shell_cdp_dir' not set. Recommended is to set it in 'PROMPT_COMMAND' or precmd()"
		return
	fi

	_shell_cdp_current_dir="$_shell_cdp_dir"
	while [ ! -d "$_shell_cdp_current_dir" ] && [ "$PWD" != / ]; do
			_shell_cdp_current_dir="$(dirname "$_shell_cdp_current_dir")"
	done

	# shellcheck disable=SC2164
	cd "$_shell_cdp_current_dir"
}

# Autogenerated. Do NOT edit!
dg() {
	dig +nocmd "$1" any +multiline +noall +answer
}

# Autogenerated. Do NOT edit!
faketty() {
	unbuffer -p "@"
}

# Autogenerated. Do NOT edit!
isup() {
	command curl -sS --head -X GET "$1" | grep -q '200 OK'
}

# Autogenerated. Do NOT edit!
kkexec() {
	sudo kexec -l /efi/EFI/arch/vmlinuz-linux-lts --initrd /efi/EFI/arch/initramfs-linux-lts.img --reuse-cmdline
	sudo systemctl kexec
	# sudo kexec -e
}

# Autogenerated. Do NOT edit!
nh() {
	nohup "$@" > /dev/null 2>&1 &
}

# Autogenerated. Do NOT edit!
see_old() {
	sudo lsof +c 0 | grep 'DEL.*lib' | awk '1 { print $1 ": " $NF }' | sort -u
}

# Autogenerated. Do NOT edit!
serv() {
    	set -- "${1:-.}" "${2:-4000}"

	[ -d "$1" ] || { _shell_util_die "serv: dir '$1' doesn't exist"; return; }

	if command -v file_server >/dev/null 2>&1; then
		# deno file_server
		file_server "$1" --host 127.0.0.1 -p "$2"

	elif command -v http-server >/dev/null 2>&1; then
		# node http-server
		http-server "$1" -c-1 -a 127.0.0.1 -p "$2"
		return
	elif command -v python3 >/dev/null 2>&1; then
		python3 -m http.server --directory "$1" "$2"
	else
		_shell_util_die "serv: no executable found to start server"
		return
	fi
}

# Autogenerated. Do NOT edit!
wa() {
	watch -cn.3 "$@"
}

# Autogenerated. Do NOT edit!
waf() {
	watch -cn.1 "$@"
}

# Autogenerated. Do NOT edit!
was() {
	watch -cn1 "$@"
}

# Autogenerated. Do NOT edit!
cdls() {
	cd -- "$1" || { _shell_util_die "cdls: cd failed"; return; }
	_shell_util_ls
}

# Autogenerated. Do NOT edit!
mkcd() {
	command mkdir -p -- "$@"
	cd -- "$@" || { _shell_util_die "mkcd: could not cd"; return; }
}

# Autogenerated. Do NOT edit!
mkmv() {
	for lastArg; do true; done
	mkdir -p "$lastArg"

	mv "$@"
}

# Autogenerated. Do NOT edit!
curl() {
	if command -v curlie >/dev/null 2>&1; then
		curlie "$@"
	else
		curl "$@"
	fi
}

# Autogenerated. Do NOT edit!
lsblk() {
	if [ $# -eq 0 ]; then
		command lsblk -o NAME,FSSIZE,FSUSED,FSAVAIL,FSUSE%,FSTYPE,MOUNTPOINT
	else
		command lsblk "$@"
	fi
}

# Autogenerated. Do NOT edit!
unlink() {
	for arg; do
		case "$arg" in
		--help|--version)
			command unlink "$@"
			return
			;;
		esac
	done

	for file; do
		command unlink "$file"
	done

	unset -v arg file
}

# Autogenerated from file. Do NOT edit!
# --------------------------------------------------------------------------------
# shellcheck shell=sh

# Common functions used in starup files for POSIX shell,
# Bash, and Zsh

_path_prepend() {
	[ -n "$2" ] && {
		# [ -d "$2" ] || return
		case ":$(eval "echo \$$1"):" in
			*":$2:"*) :;;
			*) eval "export $1=$2\${$1:+\":\$$1\"}" ;;
		esac
		return
	}

	# [ -d "$1" ] || return
	case ":$PATH:" in
		*":$1:"*) :;;
		*) export PATH="$1${PATH:+":$PATH"}"
	esac
}

_path_append() {
	[ -n "$2" ] && {
		# [ -d "$2" ] || return
		case ":$(eval "echo \$$1"):" in
			*":$2:"*) :;;
			*) eval "export $1=\${$1:+\"\$$1:\"}$2" ;;
		esac
		return
	}

	# [ -d "$1" ] || return
	case ":$PATH:" in
		*":$1:"*) :;;
		*) export PATH="${PATH:+"$PATH:"}$1"
	esac
}

_shell_util_log_error() {
	printf "\033[0;31m%s\033[0m\n" "Error: $*" >&2
}

_shell_util_log_warn() {
	printf "\033[1;33m%s\033[0m\n" "Warn: $*" >&2
}

_shell_util_log_info() {
	printf "\033[0;34m%s\033[0m\n" "Info: $*"
}

_shell_util_die() {
	_shell_util_log_error "$*"
	return 1
}

_shell_util_ls() {
	if command -v exa >/dev/null 2>&1; then
		exa -al
	elif command -v lsd >/dev/null 2>&1; then
		lsd -al
	else
		ls -al
	fi
}
